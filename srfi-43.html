<?xml version="1.0" encoding="iso-8859-1" standalone="yes" ?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <!-- Non-indentation necessary for the commit check junk. -->
<title>SRFI 43: Vector Library</title>
    <meta http-equiv="Content-type"
          content="text/html; charset=iso-8859-1" />
    <style type="text/css">
      /* <![CDATA[ */
      body {
        padding-right: 5%;
      }

      h3 {
        padding-left: 6%;
      }

      /* Ugly hack to make the header work right */
      h1.nonheader {
        padding-left: 8.5%;
      }

      H1 {
        margin-left: -4.5%;
      }

      div.header {
        padding-left: 8%;
      }

      p, dl, code.indented {
        padding-left: 8%;
      }

      ul.outer, dl.indented {
        padding-left: 13%;
      }

      ul.indented {
        padding-left: 18%;
      }

      dt.ref {
        font-weight: bold;
      }

      dt.ref:before {
        content: "[";
      }
      dt.ref:after {
        content: "]";
      }

      dt.proc-index {
        padding-left: 0.5%;
        font-size: medium;
        font-weight: bold;
      }

      dt.type-spec {
        font-family: monospace;
        font-style: italic;
      }

      dt.proc-spec {
        font-family: monospace;
      }

      code.example-call {
        padding-left: 3%;
      }
      code.example-value {
        padding-left: 8%;
      }
      code.example-value:before {
        content: "==> "
      }
      /* ]]> */
    </style>
  </head>
  <body>

    <div class="header">
<!--
     Special SRFI header, necessarily invalid XML, due to an ancient
     script written for HTML 3.2 or something.
  -->
<H1>Title</H1>

Vector Library

<H1>Author</H1>

Taylor Campbell

<i>&lt;&#99;&#97;&#109;&#112;&#98;&#101;&#108;&#108;&#32;&#40;&#97;&#116;&#41;&#32;&#101;&#118;&#100;&#101;&#118;&#32;&#40;&#100;&#111;&#116;&#41;&#32;&#97;&#116;&#104;&#32;&#40;&#100;&#111;&#116;&#41;&#32;&#99;&#120;&gt;</i>

<H1>Status</H1>
This SRFI is currently in ``draft'' status.  To see an explanation of each status that a SRFI can hold, see <A HREF="http://srfi.schemers.org/srfi-process.html">here</A>.
It will remain in draft status until 2003/04/03, or as amended.
To provide input on this SRFI, please <code><A
HREF="mailto:srfi-43@srfi.schemers.org">mail to
&lt;srfi-43@srfi.schemers.org&gt;</A></code>.  See <A HREF=../srfi-list-subscribe.html>instructions here</A> to subscribe to the list.  You can access previous messages via <A HREF=mail-archive/maillist.html>the archive of the mailing list</A>.
<P><UL>
<LI>Received: 2003/03/26
<LI>Draft: 2003/04/03-2003/06/01
<LI>Revised: 2003/07/15
</UL>
<!--
     End special header.
  -->
    </div>

    <h1 class="nonheader">Table of Contents</h1>
    <ul class="outer">
      <li>1. <a href="#Abstract">Abstract</a></li>
      <li>2. <a href="#Rationale">Rationale</a></li>
      <li>3. <a href="#ProcIndex">Procedure Index</a></li>
      <li>
        4. <a href="#Procs">Procedures</a>
        <ul>
          <li>4.1. <a href="#Constructors">Constructors</a></li>
          <li>4.2. <a href="#Predicates">Predicates</a></li>
          <li>4.3. <a href="#Accessors">Accessors</a></li>
          <li>4.4. <a href="#Miscellaneous">Miscellaneous</a></li>
          <li>4.5. <a href="#Iterators">Iterators</a></li>
          <li>4.6. <a href="#Searchers">Searchers</a></li>
          <li>4.7. <a href="#Mutators">Mutators</a></li>
          <li>4.8. <a href="#Converters">Converters</a></li>
        </ul>
      </li>
      <li>5. <a href="#RefImpl">Reference Implementation</a></li>
      <li>6. <a href="#Acknowledgements">Acknowledgements</a></li>
      <li>7. <a href="#References">References</a></li>
      <li>8. <a href="#Copyright">Copyright</a></li>
    </ul>

    <h1 class="nonheader"><a name="Abstract">1. Abstract</a></h1>
    <p>
      <a href="#R5RS">R5RS</a> provides very few list-processing
      procedures, for which reason <a href="#SRFI-1">SRFI 1
      (<tt>list-lib</tt>)</a> exists.  However,
      <a href="#R5RS">R5RS</a> provides even fewer vector operations
      &mdash; while it provides mapping, appending, et cetera
      operations for lists, it specifies only nine vector manipulation
      operations:
    </p>
    <ul class="indented">
      <li><tt><a href="#vector-p">vector?</a></tt></li>
      <li><tt><a href="#make-vector">make-vector</a></tt></li>
      <li><tt><a href="#vector">vector</a></tt></li>
      <li><tt><a href="#vector-length">vector-length</a></tt></li>
      <li><tt><a href="#vector-ref">vector-ref</a></tt></li>
      <li><tt><a href="#vector-set-bang">vector-set!</a></tt></li>
      <li><tt><a href="#vector-to-list">vector-&gt;list</a></tt></li>
      <li><tt><a href="#list-to-vector">list-&gt;vector</a></tt></li>
      <li><tt><a href="#vector-fill-bang">vector-fill!</a></tt></li>
    </ul>

    <h1 class="nonheader"><a name="Rationale">2. Rationale</a></h1>
    <p>
      Many Scheme implementations provide several other vector
      operations (the typical
      <tt><a href="#vector-append">vector-append</a></tt>,
      <tt><a href="#vector-map">vector-map</a></tt>, et cetera), but
      often these procedures have different names, take arguments in
      different orders, don't take the same number of arguments, or
      have some other flaw that makes them unportable.  For this
      reason, this SRFI is proposed.
    </p>

    <p>
      This SRFI is a comprehensive library of vector-processing
      procedures, based somewhat on <a href="#SRFI-1">SRFI 1
      (<tt>list-lib</tt>)</a> and <a href="#SRFI-13">SRFI 13
      (<tt>string-lib</tt>)</a>, with several other procedures.
    </p>

    <p>
      It should be noted that no vector sorting procedures are
      provided from this SRFI, because there already is a SRFI for such
      a purpose (<a href="#SRFI-32">SRFI-32 (<tt>sort-lib</tt>)</a>),
      which includes routines for sorting not only vectors but also
      lists.
    </p>

    <p>
      Because this SRFI is more of a library or module specification
      than a request for additions to readers or any other internal
      implementation detail, in an implementation that supports a
      module or structure or package or library or unit (or whatever
      your favourite term is) systems, these procedures should be
      contained in a module / structure / package / library / unit /
      whatever called <tt>vector-lib</tt>.
    </p>

    <h1 class="nonheader"><a name="ProcIndex">3. Procedure Index</a></h1>
    <p>
      Here is an index of the procedures provided by this package.
      Those marked by <b>bold</b> are provided in
      <a href="#R5RS">R5RS</a> and those marked by <b><i>bold
      italic</i></b> are defined by <a href="#R5RS">R5RS</a> but are
      modified from their original definitions.
    </p>
    <dl>
      <dt class="proc-index">
        &middot;&nbsp;<a href="#Constructors">Constructors</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <b><a href="#make-vector">make-vector</a></b>
          <b><a href="#vector">vector</a></b>
          <a href="#vector-tabulate">vector-tabulate</a>
          <br />
          <a href="#vector-copy">vector-copy</a>
          <a href="#vector-resize">vector-resize</a>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Predicates">Predicates</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <b><a href="#vector-p">vector?</a></b>
          <br />
          <a href="#vector-empty-p">vector-empty?</a>
          <br />
          <a href="#vector-eq">vector=</a>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Accessors">Accessors</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <b><a href="#vector-ref">vector-ref</a></b>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Miscellaneous">Miscellaneous</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <b><a href="#vector-length">vector-length</a></b>
          <br />
          <a href="#vector-copy-bang">vector-copy!</a>
          <br />
          <a href="#vector-append">vector-append</a>
          <a href="#vector-concatenate">vector-concatenate</a>
          <br />
          <a href="#vector-reverse">vector-reverse</a>
          <a href="#vector-reverse-bang">vector-reverse!</a>
          <br />
          <a href="#vector-count">vector-count</a>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Iterators">Iterators</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <a href="#vector-fold">vector-fold</a>
          <a href="#vector-fold-right">vector-fold-right</a>
          <br />
          <a href="#vector-map">vector-map</a>
          <a href="#vector-map-bang">vector-map!</a>
          <br />
          <a href="#vector-map-w-i">vector-map/index</a>
          <a href="#vector-map-w-i-bang">vector-map/index!</a>
          <br />
          <a href="#vector-for-each">vector-for-each</a>
          <a href="#vector-for-each-w-i">vector-for-each/index</a>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Searching">Searchers</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <a href="#vector-index">vector-index</a>
          <a href="#vector-index-right">vector-index-right</a>
          <br />
          <a href="#vector-skip">vector-skip</a>
          <a href="#vector-skip-right">vector-skip-right</a>
          <br />
          <a href="#vector-binary-search">vector-binary-search</a>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Mutators">Mutators</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <b><a href="#vector-set-bang">vector-set!</a></b>
          <a href="#vector-swap-bang">vector-swap!</a>
          <br />
          <b><i><a href="#vector-fill-bang">vector-fill!</a></i></b>
          <br />
          <a href="#vector-insert-bang">vector-insert!</a>
          <a href="#vector-delete-bang">vector-delete!</a>
          <br/>
          <a href="#vector-rotate-bang">vector-rotate!</a>
          <br/>
          <br/>
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Converters">Converters</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <b><i><a href="#vector-to-list">vector-&gt;list</a></i></b>
          <b><a href="#list-to-vector">list-&gt;vector</a></b>
          <br />
          <a href="#vector-to-string">vector-&gt;string</a>
          <a href="#string-to-vector">string-&gt;vector</a>
        </code>
      </dd>
    </dl>

    <h1 class="nonheader"><a name="Procs">4. Procedures</a></h1>
    <p>
      In this section containing specifications of procedures, the
      following notation is used to specify parameters and return
      values:
    </p>
    <dl class="indented">
      <dt class="type-spec">
        (f arg<sub>1</sub> arg<sub>2</sub> &middot;&middot;&middot;)
        ==&gt; something</dt>
      <dd>
        Indicates a function <tt><i>f</i></tt> takes the parameters
        <tt><i>arg<sub>1</sub> arg<sub>2</sub>
        &middot;&middot;&middot;</i></tt> and returns a value of the
        type <tt><i>something</i></tt>.  If <tt><i>something</i></tt>
        is of the form <tt><i>(t<sub>1</sub>, t<sub>2</sub>,
        &middot;&middot;&middot;)</i></tt> then <tt><i>f</i></tt>
        returns multiple values, whose types are <tt><i>t<sub>1</sub>,
        t<sub>2</sub>, &middot;&middot;&middot;</i></tt>.  If
        <tt><i>something</i></tt> is <tt>unspecific</tt>, then what
        <tt><i>f</i></tt> returns is implementation-dependant; this
        SRFI does not specify what it returns, and in order to write
        portable code, the return value should be thrown away.
        <br />
        <br />
      </dd>

      <dt class="type-spec">vec</dt>
      <dd>
        The argument in this place must be a vector, i.e. it must
        satisfy the predicate
        <tt><a href="#vector-p">vector?</a></tt>.
        <br />
        <br />
      </dd>

      <dt class="type-spec">step</dt>
      <dd>
        The argument in this place must be a number, i.e. it must
        satisfy the predicate <tt>number?</tt>.
        <br />
        <br />
      </dd>

      <dt class="type-spec">i, j, start, size</dt>
      <dd>
        The argument in this place must be a nonnegative integer, i.e.
        it must satisfy the predicates <tt>integer?</tt> and either
        <tt>zero?</tt> or <tt>positive?</tt>.  The third case of it
        indicates the index at which traversal begins; the fourth case
        of it indicates the size of a vector.
        <br />
        <br />
      </dd>

      <dt class="type-spec">end</dt>
      <dd>
        The argument in this place must be a positive integer, i.e. it
        must satisfy the predicates <tt>integer?</tt> and
        <tt>positive?</tt>.  This indicates the index directly before
        which traversal will stop &mdash; processing will occur until
        the the index of the vector is <tt><i>end</i></tt>.  This way,
        the <tt><i>end</i></tt> argument can be the same as some length
        to process up to the end of a vector.
        <br />
        <br />
      </dd>

      <dt class="type-spec">proper-list</dt>
      <dd>
        The argument in this place must be a proper list, i.e. it must
        satisfy the <a href="#SRFI-1">SRFI 1
        (<tt>list-lib</tt>)</a> predicate <tt>proper-list?</tt>.
        <br />
        <br />
      </dd>

      <dt class="type-spec">f</dt>
      <dd>
        The argument in this place must be a function of one or more
        arguments, returning exactly one value.
        <br />
        <br />
      </dd>

      <dt class="type-spec">pred?</dt>
      <dd>
        The argument in this place must be a function of one or more
        arguments that returns one value, which is treated as a
        boolean.
        <br />
        <br />
      </dd>

      <dt class="type-spec">kons</dt>
      <dd>
        The argument in this place must be a function of at least two
        arguments.
        <br />
        <br />
      </dd>

      <dt class="type-spec">elt=?</dt>
      <dd>
        The argument in this place must be a function of two arguments,
        returning a value that is considered a boolean; its arguments
        must be congruent with <tt>eq?</tt>.
        <br />
        <br />
      </dd>

      <dt class="type-spec">
        x, y, z, seed, knil, ridentity, fill, key, value
      </dt>
      <dd>
        The argument in this place may be any Scheme value.
        <br />
        <br />
      </dd>

      <dt class="type-spec">[something]</dt>
      <dd>
        Indicates that <tt><i>something</i></tt> is an optional
        argument; it needn't necessarily be applied.
        <tt><i>something</i></tt> needn't necessarily be one thing; for
        example, this usage of it is perfectly valid:
        <br />
        <br />
        <code>
          &nbsp;&nbsp;&nbsp;[start [end]]
        </code>
        <br />
        <br />
        And is indeed used quite often.
        <br />
        <br />
      </dd>

      <dt class="type-spec">something &middot;&middot;&middot;</dt>
      <dd>
        Indicates that zero or more <tt><i>something</i></tt>s are
        allowed to be arguments.
        <br />
        <br />
      </dd>

      <dt class="type-spec">
        something<sub>1</sub> something<sub>2</sub>
        &middot;&middot;&middot;
      </dt>
      <dd>
        Indicates that at least one <tt><i>something</i></tt> must be
        arguments.
        <br />
        <br />
      </dd>

      <dt class="type-spec">
        something<sub>1</sub> something<sub>2</sub>
        &middot;&middot;&middot;
        something<sub>n</sub>
      </dt>
      <dd>
        Exactly equivalent to the previous argument notation, but this
        also indicates that <tt><i>n</i></tt> will be used later in the
        procedure description.
        <br />
        <br />
      </dd>
    </dl>

    <h3><a name="Constructors">4.1. Constructors</a></h3>
    <p>
      These procedures return newly allocated vectors.
    </p>

    <dl>
      <dt class="proc-spec">
        <a name="make-vector">
          (make-vector <i>size</i> [<i>fill</i>])
          ==&gt; vector
        </a>
      </dt>
      <dd>
        [<a href="#R5RS"><i>R5RS</i></a>] Creates and returns a vector
        of size <tt><i>size</i></tt>, optionally filling it with
        <tt><i>fill</i></tt>.  The default value for
        <tt><i>fill</i></tt> is unspecified.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (make-vector 5 3)
        </code>
        <br />
        <code class="example-value">
          #(3 3 3 3 3)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector">
          (vector <i>x &middot;&middot;&middot;</i>)
          ==&gt; vector
        </a>
      </dt>
      <dd>
        [<a href="#R5RS"><i>R5RS</i></a>] Creates and returns a vector
        whose elements are <tt><i>x &middot;&middot;&middot;</i></tt>.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector 3 3 3 3 3)
        </code>
        <br />
        <code class="example-value">
          #(3 3 3 3 3)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-tabulate">
          (vector-tabulate <i>f size</i>)
          ==&gt; vector
        </a>
      </dt>
      <dd>
        Creates a new vector whose size is <tt><i>size</i></tt> and
        fills it by applying <tt><i>f</i></tt> to each index in the
        vector, in an unspecified order.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-tabulate - 5)
        </code>
        <br />
        <code class="example-value">
          #(0 -1 -2 -3 -4)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-tabulate (lambda (x) (* x x)) 5)
        </code>
        <br />
        <code class="example-value">
          #(0 1 4 9 16)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-copy">
          (vector-copy <i>vec</i> [<i>start</i> [<i>end</i>]])
          ==&gt; vector
        </a>
      </dt>
      <dd>
        Allocates a new vector of size <tt><i>start</i> -
        <i>end</i></tt> and fills it with elements in
        <tt><i>vec</i></tt>, taking elements from <tt><i>vec</i></tt>
        starting at index <tt><i>start</i></tt> and stopping at index
        <tt><i>end</i></tt>.  <tt><i>start</i></tt> defaults to
        <tt>0</tt> and <tt><i>end</i></tt> defaults to the value of
        <tt>(<a href="#vector-length">vector-length</a>
        <i>vec</i>)</tt>.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-copy '#(a b c d e f g h i))
        </code>
        <br />
        <code class="example-value">
          #(a b c d e f g h i)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-copy '#(a b c d e f g h i) 6)
        </code>
        <br />
        <code class="example-value">
          #(g h i)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-copy '#(a b c d e f g h i) 3 6)
        </code>
        <br />
        <code class="example-value">
          #(d e f)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-resize">
          (vector-resize <i>vec size</i> [<i>fill</i>])
          ==&gt; vector
        </a>
      </dt>
      <dd>
        Creates and returns a copy of <tt><i>vec</i></tt>, but with a
        size of <tt><i>size</i></tt>, the slots not filled by elements
        from <tt><i>vec</i></tt> instead being filled by
        <tt><i>fill</i></tt>, which defaults to an unspecified value.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-resize '#(0 1 2 3 4) 10 #f)
        </code>
        <br />
        <code class="example-value">
          #(0 1 2 3 4 #f #f #f #f #f)
        </code>
        <br />
        <br />
      </dd>
    </dl>

    <h3><a name="Predicates">4.2. Predicates</a></h3>
    <p>
      These procedures return boolean values based on their arguments.
    </p>

    <dl>
      <dt class="proc-spec">
        <a name="vector-p">
          (vector? <i>x</i>)
          ==&gt; boolean
        </a>
      </dt>
      <dd>
        [<a href="#R5RS"><i>R5RS</i></a>] Returns <tt>#t</tt> if
        <tt><i>x</i></tt> is a vector, and <tt>#f</tt> if otherwise.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector? '#(a b c))
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector? '(a b c))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector? #t)
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector? '#())
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector? '())
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-empty-p">
          (vector-empty? <i>vec</i>)
          ==&gt; boolean
        </a>
      </dt>
      <dd>
        Tests to see if <tt><i>vec</i></tt> contains zero elements
        &mdash; i.e., if
        <tt>(<a href="#vector-length">vector-length</a>
        <i>vec</i>)</tt> returns <tt>0</tt>.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-empty? '#(a))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-empty? '#(()))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-empty? '#(#()))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-empty? '#())
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-eq">
          (vector= <i>elt=? vec &middot;&middot;&middot;</i>)
          ==&gt; boolean
        </a>
      </dt>
      <dd>
        Compares <tt><i>vec &middot;&middot;&middot;</i></tt> with
        <tt><i>elt=?</i></tt>, comparing the first vector to the
        second, the second vector to the third, and so on and so forth
        If any of the vectors have a different length from any other,
        <tt>#f</tt> is automatically returned.  If two of the vectors
        are <tt>eq?</tt>, then their elements aren't iterated through,
        as that would be redundant.  If when the last two vectors are
        compared, <tt><i>elt=?</i></tt> returns <tt>#t</tt> when
        applied to the last element in each of those two vectors, then
        <tt>vector=</tt> returns <tt>#t</tt>.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector= eq? '#(a b c d) '#(a b c d))
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= eq? '#(a b c d) '#(a b d c))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= = '#(1 2 3 4 5) '#(1 2 3 4))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= = '#(1 2 3 4) '#(1 2 3 4))
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= eq?)
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= eq?)
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= eq? '#(#(a) #(b) #(c) #(d))
                       '#(#(a) #(b) #(c) #(d)))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= equal? '#(#(a) #(b) #(c) #(d))
                          '#(#(a) #(b) #(c) #(d)))
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
      </dd>
    </dl>

    <h3><a name="Accessors">4.3. Accessors</a></h3>
    <p>
      These procedures return certain elements of vectors.
    </p>
    <dl>
      <dt class="proc-spec">
        <a name="vector-ref">
          (vector-ref <i>vec i</i>)
          ==&gt; value
        </a>
      </dt>
      <dd>
        [<a href="#R5RS"><i>R5RS</i></a>] Reference the value in
        <tt><i>vec</i></tt> at the zero-based index <tt><i>i</i></tt>.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-ref '#(a b c d) 2)
        </code>
        <br />
        <code class="example-value">
          c
        </code>
        <br />
        <br />
      </dd>
    </dl>

    <h3><a name="Miscellaneous">4.4. Miscellaneous</a></h3>
    <p>
      These procedures do various things, like find the length of a
      vector, or append vectors.
    </p>
    <dl>
      <dt class="proc-spec">
        <a name="vector-length">
          (vector-length <i>vec</i>)
          ==&gt; exact nonnegative integer
        </a>
      </dt>
      <dd>
        Returns the length of <tt><i>vec</i></tt>.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-length '#(a b c))
        </code>
        <br />
        <code class="example-value">
          3
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-copy-bang">
          (vector-copy! <i>target tstart vec</i>
           [<i>fstart</i> [<i>fend</i>]])
          ==&gt; unspecific
        </a>
      </dt>
      <dd>
        Destructively inserts the contents of <tt><i>vec</i></tt> into
        <tt><i>target</i></tt> (both of which must be vectors),
        starting with elements in <tt><i>vec</i></tt> with
        <tt><i>fstart</i></tt> (which defaults to <tt>0</tt>), and
        ending at <tt><i>fend</i></tt>, which defaults to the length of
        <tt><i>vec</i></tt>, and inserting elements into
        <tt><i>target</i></tt> at <tt><i>tstart</i></tt>.  All of
        <tt><i>tstart</i></tt>, <tt><i>fstart</i></tt>, and
        <tt><i>fend</i></tt> must be nonnegative integers.  It is an
        error for the range [<tt><i>fstart</i></tt> ..
        <tt><i>fend</i></tt>] to be greater than the range
        [<tt><i>tstart</i></tt>
         ..
         <tt>(<a href="#vector-length">vector-length</a>
              <i>target</i>)]</tt>, or
        for <tt><i>fend</i></tt> to be greater than the length of
        <tt><i>vec</i></tt>.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (let ((target (vector 1 3 2 4 5 6 7)))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;(vector-copy! target 1 '#(-1 0 1 2 3 4 5) 3 5)
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;target)
        </code>
        <br />
        <code class="example-value">
          #(1 2 3 4 5 6 7)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-append">
          (vector-append <i>vec &middot;&middot;&middot;</i>)
          ==&gt; vector
        </a>
      </dt>
      <dd>
        Returns <tt><i>vec &middot;&middot;&middot;</i></tt>,
        appended.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-append '#(x) '#(y))
        </code>
        <br />
        <code class="example-value">
          #(x y)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-append '#(a) '#(b c d))
        </code>
        <br />
        <code class="example-value">
          #(a b c d)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-append '#(a #(b)) '#(#(c)))
        </code>
        <br />
        <code class="example-value">
          #(a #(b) #(c))
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-concatenate">
          (vector-concatenate <i>list-of-vectors</i>)
          ==&gt; vector
        </a>
      </dt>
      <dd>
        Appends each vector in <tt><i>list-of-vectors</i></tt>.
        Similar to:
        <br />
        <br />
        <code class="indented">
          (apply <a href="#vector-append">vector-append</a>
                 <i>list-of-vectors</i>)
        </code>
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-concatenate '(#(a b) #(c d)))
        </code>
        <br />
        <code class="example-value">
          #(a b c d)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-reverse">
          (vector-reverse <i>vec</i>)
          ==&gt; vector
        </a>
      </dt>
      <dd>
        Returns a newly allocated vector whose elements are the reverse
        of <tt><i>vec</i></tt>.  Note that no deep reversing is done.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-reverse '#(a b c))
        </code>
        <br />
        <code class="example-value">
          #(c b a)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-reverse '#(a #(b c) d #(e #(f))))
        </code>
        <br />
        <code class="example-value">
          #(#(e #(f)) d #(b c) a)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-reverse-bang">
          (vector-reverse! <i>vec</i> [<i>start</i> [<i>end</i>]])
          ==&gt; unspecific
        </a>
      </dt>
      <dd>
        Destructively reverses <tt><i>vec</i></tt>.  No deep reversing
        is done.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (let ((x (<a href="#vector-copy">vector-copy</a>
                    '#(a b c d e f g h i))))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;(vector-reverse! x)
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;x)
        </code>
        <br />
        <code class="example-value">
          #(i h g f e d c b a)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-count">
          (vector-count <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                           &middot;&middot;&middot;</i>)
          ==&gt; exact nonnegative integer
        </a>
      </dt>
      <dd>
        Returns the number of elements in all of the vectors to which
        <tt>vector-count</tt> was applied which satisfy the predicate
        <tt><i>pred</i></tt>.  For each vector to which
        <tt>vector-count</tt> was applied, <tt><i>pred?</i></tt> should
        take one argument.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-count even? '#(3 1 4 1 5 9 2 5 6))
        </code>
        <br />
        <code class="example-value">
          3
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-count &lt; '#(1 3 6 9) '#(2 4 6 8 10 12))
        </code>
        <br />
        <code class="example-value">
          2
        </code>
        <br />
        <br />
      </dd>
    </dl>

    <h3><a name="Iterators">4.5. Iterators</a></h3>
    <p>
      These procedures iterate over the elements in vectors.
    </p>
    <dl>
      <dt class="proc-spec">
        <a name="vector-fold">
          (vector-fold <i>kons knil vec<sub>1</sub> vec<sub>2</sub>
                          &middot;&middot;&middot;</i>)
          ==&gt; value
        </a>
      </dt>
      <dd>
        The fundamental vector iterator.  It applies
        <tt><i>kons</i></tt> to the <tt><i>i</i></tt><sup>th</sup>
        elements in the vectors applied, and with the last argument
        being the current <tt><i>knil</i></tt> value, which is the
        value returned by <tt><i>kons</i></tt> at the last iteration,
        where <tt><i>i</i></tt> is an exact, nonnegative integer,
        starting at <tt>0</tt>, and incremented by <tt>1</tt> at each
        iteration, until <tt><i>i</i></tt> is as high as the shortest
        length of <tt><i>vec<sub>1</sub> vec<sub>2</sub>
        &middot;&middot;&middot;</i></tt>, in which case the last value
        that <tt><i>kons</i></tt> returned is returned.  It being
        difficult to describe in English, see the examples.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <br />
        Finds the longest string's length in
        <tt><i>vector-of-strings</i></tt>.
        <br />
        <code class="example-call">
          (vector-fold (lambda (str len) (max (string-length str)
                                              len)) 0
                       <i>vector-of-strings</i>)
        </code>
        <br />
        <br />
        Produce a list of the reversed elements of
        <tt><i>vec</i></tt>.
        <br />
        <code class="example-call">
          (vector-fold cons '() <i>vec</i>)
        </code>
        <br />
        <br />
        Count the number of even numbers in <tt><i>vec</i></tt>.
        <br />
        <code class="example-call">
          (vector-fold (lambda (n counter) (if (even? n)
                                               (+ counter 1)
                                               counter))
                       0 <i>vec</i>)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-fold-right">
          (vector-fold-right <i>kons knil
                                vec<sub>1</sub> vec<sub>2</sub>
                                &middot;&middot;&middot;</i>)
          ==&gt; value
        </a>
      </dt>
      <dd>
        Similar to <tt><a href="#vector-fold">vector-fold</a></tt>, but
        iterates right to left instead of left to right.
        <br />
        <br />
        Example:
        <br />
        <br />
        Convert a vector to a list.
        <br />
        <code class="example-call">
          (vector-fold-right cons '() '#(a b c d))
        </code>
        <br />
        <code class="example-value">
          (a b c d)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-map">
          (vector-map <i>f vec<sub>1</sub> vec<sub>2</sub>
                         &middot;&middot;&middot;</i>)
          ==&gt; vector
        </a>
      </dt>
      <dd>
        Constructs a new vector of the shortest size of the vectors,
        and for each index <tt><i>i</i></tt> in <tt><i>vec<sub>1</sub>
        vec<sub>2</sub> &middot;&middot;&middot;</i></tt> until the
        shortest vector runs out, puts the result of applying
        <tt><i>f</i></tt> to the <tt><i>i</i></tt><sup>th</sup>
        elements in the vectors into the
        <tt><i>i</i></tt><sup>th</sup> element in the new vector,
        returning the new vector.  The dynamic order of application is
        unspecified.
        <br />
        <br />
        <tt>vector-map</tt> and all variants thereof (including
        <tt>for-each</tt> variants) may take vectors of unequal size,
        in which case they must stop iteration at the end of the
        shortest vector.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-map (lambda (x) (* x x))
                      (<a href="#vector-iota">vector-iota</a> 4 1))
        </code>
        <br />
        <code class="example-value">
          #(1 4 9 16)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-map *
                      (<a href="#vector-iota">vector-iota</a> 5 1)
                      (<a href="#vector-iota">vector-iota</a> 5 5 -1))
        </code>
        <br />
        <code class="example-value">
          #(5 8 9 8 5)
        </code>
        <br />
        <br />
        <code class="example-call">
          (let ((count 0))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;
          (vector-map (lambda (ignored)
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (set! count (+ count 1))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          count)
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;
          '#(a b)
        </code>
        <br />
        <code class="example-value">
          #(1 2) <i>OR</i> #(2 1)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-map-bang">
          (vector-map! <i>f vec<sub>1</sub> vec<sub>2</sub>
                          &middot;&middot;&middot;</i>)
          ==&gt; unspecific
        </a>
      </dt>
      <dd>
        Similar to <tt><a href="#vector-map">vector-map</a></tt>, but
        instead of returning the resulting vector, destructively
        inserts each value that <tt><i>f</i></tt> returned for each
        element into
        <tt><i>vec<sub>1</sub></i></tt> at the same index.  Again, the
        dynamic order of application is unspecified, so it is dangerous
        for <tt><i>f</i></tt> to apply either
        <tt><a href="#vector-ref">vector-ref</a></tt> or
        <tt><a href="#vector-set-bang">vector-set!</a></tt> to
        <tt><i>vec<sub>1</sub></i></tt> in <tt><i>f</i></tt>.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-map-w-i">
          (vector-map/index <i>f vec<sub>1</sub> vec<sub>2</sub>
                               &middot;&middot;&middot;</i>)
          ==&gt; vector
        </a>
      </dt>
      <dd>
        Similar to <tt><a href="#vector-map">vector-map</a></tt>, but
        <tt><i>f</i></tt> is called with the index of each element as
        well as the elements.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-map/index (lambda (x y) (+ x y)) '#(1 2 3 4))
        </code>
        <br />
        <code class="example-value">
          #(1 3 5 7)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-map-w-i-bang">
          (vector-map/index! <i>f vec<sub>1</sub> vec<sub>2</sub>
                                &middot;&middot;&middot;</i>)
          ==&gt; unspecified
        </a>
      </dt>
      <dd>
        Similar to <tt><a href="#vector-map-bang">vector-map!</a></tt>,
        but, like
        <tt><a href="#vector-map-w-i">vector-map/index</a></tt>,
        calls <tt><i>f</i></tt> with the index as well as the elements.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-for-each">
          (vector-for-each <i>f vec<sub>1</sub> vec<sub>2</sub>
                              &middot;&middot;&middot;</i>)
          ==&gt; unspecific
        </a>
      </dt>
      <dd>
        Applies <tt><i>f</i></tt> to each element in
        <tt><i>vec<sub>1</sub> vec<sub>2</sub>
        &middot;&middot;&middot;</i></tt>, in order from left to right,
        and stops when the end of the shortest vector is reached.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-for-each (lambda (x) (display x) (newline))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          '#("foo" "bar" "baz" "quux" "zot"))
        </code>
        <br />
        Displays:
        <br />
        <pre>
foo
bar
baz
quux
zot</pre>        
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-for-each-w-i">
          (vector-for-each/index <i>f vec<sub>1</sub> vec<sub>2</sub>
                                    &middot;&middot;&middot;</i>)
        </a>
      </dt>
      <dd>
        Like <tt><a href="#vector-for-each">vector-for-each</a></tt>,
        but calls <tt><i>f</i></tt> with the index as well as the
        elements.
      </dd>
    </dl>

    <h3><a name="Searchers">4.6. Searchers</a></h3>
    <p>
      These functions look for elements in vectors based on certain
      criteria.
    </p>
    <dl>
      <dt class="proc-spec">
        <a name="vector-index">
          (vector-index <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                           &middot;&middot;&middot;</i>)
          ==&gt; exact nonnegative integer or #f
        </a>
      </dt>
      <dd>
        Returns the index of the first elements in
        <tt><i>vec<sub>1</sub> vec<sub>2</sub>
        &middot;&middot;&middot;</i></tt> that satisfy
        <tt><i>pred?</i></tt>.  Iteration runs until the end of the
        shortest vector, at which point <tt>#f</tt> is returned.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-index even? '#(3 1 4 1 5 9))
        </code>
        <br />
        <code class="example-value">
          2
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-index &lt; '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2))
        </code>
        <br />
        <code class="example-value">
          1
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-index = '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-index-right">
          (vector-index-right <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                                 &middot;&middot;&middot;</i>)
          ==&gt; exact nonnegative integer or #f
        </a>
      </dt>
      <dd>
        Returns the index of the first elements in
        <tt><i>vec<sub>1</sub> vec<sub>2</sub>
        &middot;&middot;&middot;</i></tt> that satisfy
        <tt><i>pred?</i></tt>, traversing the vector right to left.  If
        none of the values in the vectors satisfy
        <tt><i>pred?</i></tt>, <tt>#f</tt> is returned.  All of the
        vectors <i>must</i> have the same length.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-index-right number? '#(a b 3 4 e f))
        </code>
        <br />
        <code class="example-value">
          3
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-skip">
          (vector-skip <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                          &middot;&middot;&middot;</i>)
          ==&gt; exact nonnegative integer or #f
        </a>
      </dt>
      <dd>
        Returns the index of the first elements in
        <tt><i>vec<sub>1</sub> vec<sub>2</sub>
        &middot;&middot;&middot;</i></tt> that do <i>not</i> satisfy
        <tt><i>pred?</i></tt>.  If all the values in the vectors
        satisfy <tt><i>pred?</i></tt>, <tt>#f</tt> is returned.
        Equivalent to:
        <br />
        <br />
        <code class="indented">
          (<a href="#vector-index">vector-index</a>
           (lambda (x) (not (<i>pred?</i> x)))
           <i>vec<sub>1</sub> vec<sub>2</sub>
           &middot;&middot;&middot;</i>)
        </code>
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-skip number? '#(1 2 a b 3 4 c d))
        </code>
        <br />
        <code class="example-value">
          2
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-skip-right">
          (vector-skip-right <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                                &middot;&middot;&middot;</i>)
          ==&gt; exact nonnegative integer or #f
        </a>
      </dt>
      <dd>
        Returns the index of the first elements in
        <tt><i>vec<sub>1</sub> vec<sub>2</sub>
        &middot;&middot;&middot;</i></tt> that do <i>not</i> satisfy
        <tt><i>pred?</i></tt>, traversing the vectors right to left.
        If all of the values in the vectors satisfy
        <tt><i>pred?</i></tt>, <tt>#f</tt> is returned.  All of the
        vectors <i>must</i> have the same length.  Equivalent to:
        <br />
        <br />
        <code class="indented">
          (<a href="#vector-index-right">vector-index-right</a>
           (lambda (x) (not (<i>pred?</i> x)))
           <i>vec<sub>1</sub> vec<sub>2</sub>
           &middot;&middot;&middot;</i>)
        </code>
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-skip-right number? '#(1 2 a b 5 6))
        </code>
        <br />
        <code class="example-value">
          3
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-binary-search">
          (vector-binary-search <i>vec value cmp</i>)
          ==&gt; exact nonnegative integer or #f
        </a>
      </dt>
      <dd>
        Similar to <tt><a href="#vector-index">vector-index</a></tt>
        and
        <tt><a href="#vector-index-right">vector-index-right</a></tt>,
        but instead of searching left to right or right to left, it
        binary-searches.  <tt><i>cmp</i></tt> should be a procedure of
        two arguments and return one of the symbols <tt>lt</tt>,
        <tt>eq</tt>, or <tt>gt</tt>.  An example <tt><i>cmp</i></tt>
        might be:
        <br />
        <br />
        <code class="indented">
          (lambda (<i>int<sub>1</sub></i> <i>int<sub>2</sub></i>)
        </code>
        <br />
        <code class="indented">
          &nbsp;&nbsp;(cond
        </code>
        <br />
        <code class="indented">
          &nbsp;&nbsp;&nbsp;((&lt; <i>int<sub>1</sub>
                                      int<sub>2</sub></i>)
                             'lt)
        </code>
        <br />
        <code class="indented">
          &nbsp;&nbsp;&nbsp;((= <i>int<sub>1</sub> int<sub>2</sub></i>)
                             'eq)
        </code>
        <br />
        <code class="indented">
          &nbsp;&nbsp;&nbsp;(else 'gt)))
        </code>
        <br />
        <br />
      </dd>
    </dl>

    <h3><a name="Mutators">4.7. Mutators</a></h3>
    <p>
      These procedures destructively mutate their arguments.
    </p>
    <dl>
      <dt class="proc-spec">
        <a name="vector-set-bang">
          (vector-set! <i>vec i value</i>)
          ==&gt; unspecific
        </a>
      </dt>
      <dd>
        Changes the value in <tt><i>vec</i></tt> at <tt><i>i</i></tt>
        to <tt><i>value</i></tt>.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-swap-bang">
          (vector-swap! <i>vec i j</i>)
          ==&gt; unspecific
        </a>
      </dt>
      <dd>
        Destructively swaps the values in <tt><i>vec</i></tt> at
        <tt><i>i</i></tt> and <tt><i>j</i></tt>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-fill-bang">
          (vector-fill! <i>vec x</i> [<i>start</i> [<i>end</i>]])
          ==&gt; unspecific
        </a>
      </dt>
      <dd>
        Puts <tt><i>x</i></tt> into every slot in <tt><i>vec</i></tt>,
        possibly between <tt><i>start</i></tt> and <tt><i>end</i></tt>.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-insert-bang">
          (vector-insert! <i>vec i value</i>)
          ==&gt; unspecific
        </a>
      </dt>
      <dd>
        Inserts <tt><i>value</i></tt> at <tt><i>i</i></tt> in
        <tt><i>vec</i></tt>, shifting values whose indices are greater
        than <tt><i>i</i></tt> right, dropping off the last value.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (let ((vec (vector 0 1 3 4 5)))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;(vector-insert! vec 2 2)
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;vec)
        </code>
        <br />
        <code class="example-value">
          #(0 1 2 3 4)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-delete-bang">
          (vector-delete! <i>vec i</i> [<i>last</i>])
        </a>
      </dt>
      <dd>
        Shifts all the values whose indices are greater than
        <tt><i>i</i></tt> left, eliminating the value at
        <tt><i>i</i></tt>, and putting either <tt><i>last</i></tt> or,
        if <tt><i>last</i></tt> is not present, an unspecified value,
        at the end of <tt><i>vec</i></tt>.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (let ((vec (vector 0 1 2 2 3)))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;(vector-delete! vec 2 4)
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;vec)
        </code>
        <br />
        <code class="example-value">
          #(0 1 2 3 4)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-rotate-bang">
          (vector-rotate! <i>vec</i> [<i>n</i>])
        </a>
      </dt>
      <dd>
        Circularly (i.e. elements at the end go to the beginning)
        rotates each element in <tt><i>vec</i></tt> right
        <tt><i>n</i></tt> (or if <tt><i>n</i></tt> is negative, left),
        which defaults to <tt>1</tt>.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (let ((vec (vector 1 2 3 4 0)))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;(vector-rotate! vec)
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;vec)
        </code>
        <br />
        <code class="example-value">
          #(0 1 2 3 4)
        </code>
        <br />
        <br />
        <code class="example-call">
          (let ((vec (vector 3 4 0 1 2)))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;(vector-rotate! vec -2)
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;vec)
        </code>
        <br />
        <code class="example-value">
          #(0 1 2 3 4)
        </code>
        <br />
        <br />
      </dd>
    </dl>

    <h3><a name="Conversion">4.11. Conversion</a></h3>
    <p>
      Converts values to vectors and vectors to other values.
    </p>
    <dl>
      <dt class="proc-spec">
        <a name="vector-to-list">
          (vector-&gt;list <i>vec</i> [<i>start</i> [<i>end</i>]])
          ==&gt; proper-list
        </a>
      </dt>
      <dd>
        Converts a vector to a list, possibly from the elements between
        <tt><i>start</i></tt> and <tt><i>end</i></tt>.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-&gt;list '#(0 1 2 a b c six seven eight) 3 6)
        </code>
        <br />
        <code class="example-value">
          (a b c)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="list-to-vector">
          (list-&gt;vector <i>proper-list</i>)
          ==&gt; vector
        </a>
      </dt>
      <dd>
        Converts a list to a vector.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (list-&gt;vector '(a b c)
        </code>
        <br />
        <code class="example-value">
          #(a b c)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-to-string">
          (vector-&gt;string <i>vec</i> [<i>start</i> [<i>end</i>]])
          ==&gt; string
        </a>
      </dt>
      <dd>
        Converts a vector to a string.  Despite the fact that strings
        and vectors are essentially equivalent, it is occasionally
        useful to convert one to the other.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-&gt;string '#(#\f #\o #\o #\b #\a #\r #\b #\a #\z)
                             3 6)
        </code>
        <br />
        <code class="example-value">
          "bar"
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="string-to-vector">
          (string-&gt;vector <i>vec</i> [<i>start</i> [<i>end</i>]])
          ==&gt; vector
        </a>
      </dt>
      <dd>
        Converts a string to a vector.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (string-&gt;vector "foobarbaz" 3 6)
        </code>
        <br />
        <code class="example-value">
          #(#\b #\a #\r)
        </code>
        <br />
        <br />
      </dd>
    </dl>

    <h1 class="nonheader">
      <a name="RefImpl">5. Reference Implementation</a>
    </h1>
    <p>
      With this SRFI comes a complete reference implementation.  It is
      licensed under a very 'open' copyright, much like SRFIs
      <a href="#SRFI-1">1</a> and <a href="#SRFI-13">13</a>.
      <br />
      <br />
      The reference implementation requires three other
      SRFIs &mdash; <a href="#SRFI-1">SRFI 1 (<tt>list-lib</tt>)</a>,
      <a href="#SRFI-23">SRFI 23 (<tt>error</tt>)</a>, and
      <a href="#SRFI-26">SRFI 26 (<tt>cut / cute</tt>)</a>.
      <br />
      <br />
      This reference implementation of all the procedures described in
      this SRFI can be found <a href="vector-lib.scm">here</a>.
    </p>

    <h1 class="nonheader">
      <a name="Acknowledgements">6. Acknowledgements</a>
    </h1>
    <p>
      Thanks to Olin Shivers for his wonderfully complete
      <a href="#SRFI-1">list</a> and <a href="#SRFI-13">string</a>
      packages, which were a great help not only for finding various
      procedures to put in this package, but also his reference
      implementations were very helpful in writing mine, they being
      especially clear and well-commented; to all the members of the
      <a href="http://www.bloodandcoffee.net/campbell/html/scheme-irc.html">
      <tt>#scheme</tt> IRC channel</a> on
      <a href="http://www.freenode.net/">Freenode</a> who nitpicked a
      great deal, but also helped quite a lot in general, and helped
      test the reference implementation in various Scheme systems; to
      Michael Burschik for his various comments; to Sergei Egorov for
      helping narrow down the procedures; et cetera.
    </p>

    <h1 class="nonheader"><a name="References">7. References</a></h1>
    <dl>
      <dt class="ref"><a name="R5RS">R5RS</a></dt>
      <dd>
        <i>R5RS: The Revised<sup>5</sup> Report on Scheme</i>
        <br />
        R. Kelsey, W. Clinger, J. Rees (editors).
        <br />
        Higher-Order and Symbolic Computation, Vol. 11, No. 1,
        September, 1998
        <br />
        and
        <br />
        ACM SIGPLAN Notices, Vol. 33, No. 9, October, 1998
        <br />
        Available at:
        <a href="http://www.schemers.org/Documents/Standards/R5RS/">
          http://www.schemers.org/Documents/Standards/R5RS/
        </a>
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="SRFI">SRFI</a></dt>
      <dd>
        <i>SRFI: Scheme Request for Implementation</i>
        <br />
        The SRFI website can be found at:
        <a href="http://srfi.schemers.org/">
          http://srfi.schemers.org
        </a>
        The SRFIs mentioned in this document are described later.
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="SRFI-1">SRFI-1</a></dt>
      <dd>
        <i>SRFI 1: List Library</i>
        <br />
        A SRFI of list processing procedures, written by Olin Shivers.
        <br />
        Available at:
        <a href="http://srfi.schemers.org/srfi-1/">
          http://srfi.schemers.org/srfi-1/
        </a>
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="SRFI-13">SRFI-13</a></dt>
      <dd>
        <i>SRFI 13: String Library</i>
        <br />
        A SRFI of string processing procedures, written by Olin
        Shivers.
        <br />
        Available at:
        <a href="http://srfi.schemers.org/srfi-13/">
          http://srfi.schemers.org/srfi-13/
        </a>
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="SRFI-23">SRFI-23</a></dt>
      <dd>
        <i>SRFI 23: Error Reporting Mechanism</i>
        <br />
        A SRFI that defines a new primitive (<tt>error</tt>) for
        reporting that an error occurred, written by Stephan Houben.
        <br />
        Available at:
        <a href="http://srfi.schemers.org/srfi-23/">
          http://srfi.schemers.org/srfi-23/
        </a>
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="SRFI-26">SRFI-26</a></dt>
      <dd>
        <i>
          SRFI 26: Notation for Specializing Parameters without
          Currying
        </i>
        <br />
        A SRFI that defines two macros for specializing parameters,
        <tt>cut</tt> and <tt>cute</tt>, written by Sebastian Egner.
        <br />
        Available at:
        <a href="http://srfi.schemers.org/srfi-26/">
          http://srfi.schemers.org/srfi-26/
        </a>
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="SRFI-32">SRFI-32</a></dt>
      <dd>
        <i>SRFI 32: Sort Libraries (draft)</i>
        <br />
        A SRFI of list and vector sorting routines, written by Olin
        Shivers.
        <br />
        Available at:
        <a href="http://srfi.schemers.org/srfi-32/">
          http://srfi.schemers.org/srfi-32/
        </a>
      </dd>
    </dl>

    <h1 class="nonheader"><a name="Copyright">8. Copyright</a></h1>
    <p>
     Copyright (C) Taylor Campbell (2003).  All rights reserved.
    </p>
    <p>
      This document and translations of it may be copied and furnished
      to others, and derivative works that comment on or otherwise
      explain it or assist in its implementation may be prepared,
      copied, published, and distributed, in whole or in part, without
      restriction of any kind, provided that the above copyright notice
      and this paragraph are included on all such copies and derivative
      works.  However, this document itself may not be modified in any
      way, such as by removing the copyright notice or references to
      the Scheme Request For Implementation process or editors, except
      as needed for the purpose of developing SRFIs in which case the
      procedures for copyrights defined in the SRFI process must be
      followed, or as required to translate it into languages other
      than English.
    </p>
    <p>
      The limited permissions granted above are perpetual and will not
      be revoked by the authors or their successors or assigns.
    </p>
    <p>
      This document and the information contained herein are provided
      on an "AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM
      ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
      ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT
      INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY
      OR FITNISS FOR A PARTICULAR PURPOSE.
    </p>
  </body>
</html>
